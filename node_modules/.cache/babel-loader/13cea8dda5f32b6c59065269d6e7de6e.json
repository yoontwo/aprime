{"ast":null,"code":"var POST_DECIMAL_DIGITS = 10;\nexport var baseUnit = 24;\nexport var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\nexport var arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\n\nexport var translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};","map":{"version":3,"sources":["C:/Users/백지윤/Desktop/React/mbti/node_modules/grommet/es6/utils/graphics.js"],"names":["POST_DECIMAL_DIGITS","baseUnit","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","Math","PI","x","cos","y","sin","arcCommands","startAngle","endAngle","normalizedEndAngle","start","end","arcSweep","d","toFixed","join","translateEndAngle","anglePer","value","max"],"mappings":"AAAA,IAAIA,mBAAmB,GAAG,EAA1B;AACA,OAAO,IAAIC,QAAQ,GAAG,EAAf;AACP,OAAO,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,OAA1B,EAAmCC,OAAnC,EAA4CC,MAA5C,EAAoDC,cAApD,EAAoE;AAChG,MAAIC,cAAc,GAAG,CAACD,cAAc,GAAG,EAAlB,IAAwBE,IAAI,CAACC,EAA7B,GAAkC,KAAvD;AACA,SAAO;AACLC,IAAAA,CAAC,EAAEP,OAAO,GAAGE,MAAM,GAAGG,IAAI,CAACG,GAAL,CAASJ,cAAT,CADjB;AAELK,IAAAA,CAAC,EAAER,OAAO,GAAGC,MAAM,GAAGG,IAAI,CAACK,GAAL,CAASN,cAAT;AAFjB,GAAP;AAID,CANM;AAOP,OAAO,IAAIO,WAAW,GAAG,SAASA,WAAT,CAAqBX,OAArB,EAA8BC,OAA9B,EAAuCC,MAAvC,EAA+CU,UAA/C,EAA2DC,QAA3D,EAAqE;AAC5F;AACA,MAAIC,kBAAkB,GAAGD,QAAzB;AACA;AACF;AACA;AACA;AACA;;AAEE,MAAIA,QAAQ,GAAGD,UAAX,IAAyBC,QAAQ,GAAGD,UAAX,IAAyB,GAAtD,EAA2D;AACzDE,IAAAA,kBAAkB,GAAGF,UAAU,GAAG,MAAlC;AACD;;AAED,MAAIG,KAAK,GAAGhB,gBAAgB,CAACC,OAAD,EAAUC,OAAV,EAAmBC,MAAnB,EAA2BY,kBAA3B,CAA5B;AACA,MAAIE,GAAG,GAAGjB,gBAAgB,CAACC,OAAD,EAAUC,OAAV,EAAmBC,MAAnB,EAA2BU,UAA3B,CAA1B;AACA,MAAIK,QAAQ,GAAGH,kBAAkB,GAAGF,UAArB,IAAmC,GAAnC,GAAyC,GAAzC,GAA+C,GAA9D;AACA,MAAIM,CAAC,GAAG,CAAC,GAAD,EAAMH,KAAK,CAACR,CAAN,CAAQY,OAAR,CAAgBtB,mBAAhB,CAAN,EAA4CkB,KAAK,CAACN,CAAN,CAAQU,OAAR,CAAgBtB,mBAAhB,CAA5C,EAAkF,GAAlF,EAAuFK,MAAM,CAACiB,OAAP,CAAetB,mBAAf,CAAvF,EAA4HK,MAAM,CAACiB,OAAP,CAAetB,mBAAf,CAA5H,EAAiK,CAAjK,EAAoKoB,QAApK,EAA8K,CAA9K,EAAiLD,GAAG,CAACT,CAAJ,CAAMY,OAAN,CAActB,mBAAd,CAAjL,EAAqNmB,GAAG,CAACP,CAAJ,CAAMU,OAAN,CAActB,mBAAd,CAArN,EAAyPuB,IAAzP,CAA8P,GAA9P,CAAR;AACA,SAAOF,CAAP;AACD,CAlBM;AAmBP;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIG,iBAAiB,GAAG,SAASA,iBAAT,CAA2BT,UAA3B,EAAuCU,QAAvC,EAAiDC,KAAjD,EAAwD;AACrF,SAAOlB,IAAI,CAACmB,GAAL,CAAS,CAAT,EAAYZ,UAAU,GAAGU,QAAQ,GAAGC,KAApC,IAA6C,GAApD;AACD,CAFM","sourcesContent":["var POST_DECIMAL_DIGITS = 10;\nexport var baseUnit = 24;\nexport var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\nexport var arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\n\nexport var translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};"]},"metadata":{},"sourceType":"module"}